package tag

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"golang.org/x/xerrors"
)

const (
	genWriter = "GenWriter"
)

// GenWriter implementation
type GenWriter struct {
	writer io.Writer
	prefix string
}

var _ = (*io.Writer)(nil)

func (w *GenWriter) Write(p []byte) (int, error) {
	intVal, err := w.writer.Write(append([]byte(w.prefix), p...))
	if err != nil {
		return 0, xerrors.Errorf("failed to write to buffer: %w", err)
	}
	return intVal, nil
}

func (w *GenWriter) Wln(p string) {
	_, err := w.Write([]byte(p + "\n"))
	validateCodeGeneration(err, genWriter)
}

func (w *GenWriter) Wf(format string, args ...interface{}) {
	w.Wln(fmt.Sprintf(format, args...))
}

func (w *GenWriter) WithIndent() *GenWriter {
	return &GenWriter{
		writer: w,
		prefix: "\t",
	}
}

func (w *GenWriter) GenerateAutomatedComment() {
	// TODO: Link documentation to the generated comments; will implement once documentation is complete
	w.Wf(`// Code is generated by Template API Generator (TAG). DO NOT EDIT.`)
}

func (w *GenWriter) GenerateComment(comment string) {
	w.Wf("// %s", comment)
}

func (w *GenWriter) CreatePackage(packageName string) {
	w.Wf("package %s \n", packageName)
}

func (w *GenWriter) GenerateImport(filename string) string {
	vars := make(map[string]interface{})
	templatedCode := ProcessTemplate(filename, vars)
	return templatedCode
}

func Init() (*bytes.Buffer, *GenWriter) {
	b := &bytes.Buffer{}
	w := &GenWriter{
		writer: b,
	}
	return b, w
}

func CreateMap(varName string, keyType string, valueType string, keys []string, values []string) bytes.Buffer {
	b, w := Init()
	w.Wf("var (")
	{
		w := w.WithIndent()
		w.Wf("%s = map[%s]%s{", varName, keyType, valueType)
		{
			w.WithIndent()
			for i := 0; i < len(keys); i++ {
				w.Wf("%s: %s,", keys[i], values[i])
			}
		}
		w.Wln("}")
	}
	w.Wln(") \n")
	return *b
}

func validateCodeGeneration(err error, section string) {
	if err != nil {
		err = xerrors.Errorf("TAG encountered error with code generation: %s; %w", section, err)
		panic(err)
	}
}

func ValidateFileSystems(err error, section string) {
	if err != nil {
		err = xerrors.Errorf("TAG encountered error with file systems: %s; %w", section, err)
		panic(err)
	}
}

func CreateAndWrite(b string, filename string) {
	f, err := os.Create(filename) // #nosec G304 - False positive: file paths are not based on user or external input
	ValidateFileSystems(err, "creating file")
	_, err = f.WriteString(b)
	ValidateFileSystems(err, "writing buffer to file")
	err = f.Close()
	ValidateFileSystems(err, "closing file")
}

// Methods used for text/template files

func ProcessTemplate(fileName string, vars interface{}) string {
	directory := strings.Split(fileName, "/")
	fileName = directory[len(directory)-1]
	directory = directory[:len(directory)-1]
	fileDirectory := strings.Join(directory, "/") + "/*.tmpl"
	t, err := template.ParseFS(TagFS, fileDirectory)
	if err != nil {
		panic(err)
	}
	var tmplBytes bytes.Buffer
	if err = t.ExecuteTemplate(&tmplBytes, fileName, vars); err != nil {
		panic(err)
	}
	return tmplBytes.String()
}
